{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-680fea7986eaaa5b763e792f1e91c9233da2c3d8",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/SubsidyPayout.sol": "project/contracts/SubsidyPayout.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/SubsidyPayout.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/// @title SubsidyPayout - Automated subsidy disbursement aligned with programs schema\r\n/// @notice Mirrors the backend programs schema (programs, eligibility, payout rule) and executes payouts once an oracle approves claims.\r\ncontract SubsidyPayout {\r\n    enum ProgramType {\r\n        DROUGHT,\r\n        FLOOD,\r\n        CROP_LOSS\r\n    }\r\n\r\n    enum ProgramStatus {\r\n        DRAFT,\r\n        ACTIVE\r\n    }\r\n\r\n    enum ClaimStatus {\r\n        PendingReview,\r\n        Approved,\r\n        Rejected,\r\n        Paid\r\n    }\r\n\r\n    struct Eligibility {\r\n        bool hasMinFarmSize;\r\n        bool hasMaxFarmSize;\r\n        uint256 minFarmSize;\r\n        uint256 maxFarmSize;\r\n        string[] states;\r\n        string[] districts;\r\n        string[] cropTypes;\r\n        string[] certifications;\r\n    }\r\n\r\n    struct PayoutRule {\r\n        uint256 amount; // fixed payout per claim (wei)\r\n        uint256 maxCap; // total cap for the programs (0 = uncapped)\r\n    }\r\n\r\n    struct Program {\r\n        string name;\r\n        string description;\r\n        ProgramType programsType;\r\n        ProgramStatus status;\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        string createdBy; // mirrors prisma createdBy string\r\n        bytes32 metadataHash; // hash/pointer to full off-chain programs config\r\n        PayoutRule payoutRule;\r\n        Eligibility eligibility;\r\n        uint256 totalDisbursed;\r\n    }\r\n\r\n    struct Claim {\r\n        uint256 programsId;\r\n        address farmer;\r\n        uint256 amount;\r\n        ClaimStatus status;\r\n        bytes32 metadataHash; // hash/pointer to off-chain claim metadata\r\n        uint256 submittedAt;\r\n        string rejectionReason;\r\n    }\r\n\r\n    address public owner;\r\n    address public oracle; // trusted oracle/approver for automatic payouts\r\n    mapping(address => bool) public isGovernment; // multiple government addresses\r\n\r\n    uint256 public nextProgramId = 1;\r\n    uint256 public nextClaimId = 1;\r\n\r\n    mapping(uint256 => Program) public programs;\r\n    mapping(uint256 => Claim) public claims;\r\n    mapping(address => uint256[]) public enrolledPrograms; // farmer => list of programsIds\r\n    mapping(uint256 => mapping(address => bool)) public isFarmerEnrolled; // programsId => farmer enrolled\r\n    mapping(address => uint256) public agencyFunds; // agency address => balance (wei)\r\n\r\n    bool private reentrancyLock;\r\n\r\n    event OwnerUpdated(address indexed owner);\r\n    event OracleUpdated(address indexed oracle);\r\n    event GovernmentRoleGranted(address indexed account);\r\n    event GovernmentRoleRevoked(address indexed account);\r\n    event FundsDeposited(address indexed from, uint256 amount);\r\n    event ContractFunded(address indexed agency, uint256 amount);\r\n    event ProgramCreated(\r\n        uint256 indexed programsId,\r\n        string name,\r\n        ProgramType programsType,\r\n        ProgramStatus status,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        bytes32 metadataHash,\r\n        uint256 payoutAmount,\r\n        uint256 payoutMaxCap\r\n    );\r\n    event ProgramStatusUpdated(\r\n        uint256 indexed programsId,\r\n        ProgramStatus status\r\n    );\r\n    event ProgramUpdated(\r\n        uint256 indexed programsId,\r\n        uint256 payoutAmount,\r\n        uint256 payoutMaxCap\r\n    );\r\n    event EligibilityUpdated(uint256 indexed programsId);\r\n    event ClaimSubmitted(\r\n        uint256 indexed claimId,\r\n        uint256 indexed programsId,\r\n        address indexed farmer,\r\n        uint256 amount,\r\n        bytes32 metadataHash\r\n    );\r\n    event FarmerEnrolled(address indexed farmer, uint256 indexed programsId);\r\n    event AutoClaimCreated(\r\n        uint256 indexed claimId,\r\n        uint256 indexed programsId,\r\n        address indexed farmer\r\n    );\r\n    event ClaimApproved(\r\n        uint256 indexed claimId,\r\n        uint256 indexed programsId,\r\n        address indexed farmer,\r\n        uint256 amount\r\n    );\r\n    event ClaimPaid(\r\n        uint256 indexed claimId,\r\n        uint256 indexed programsId,\r\n        address indexed farmer,\r\n        uint256 amount\r\n    );\r\n    event ClaimRejected(\r\n        uint256 indexed claimId,\r\n        uint256 indexed programsId,\r\n        address indexed farmer,\r\n        string reason\r\n    );\r\n    event ClaimDisbursed(\r\n        uint256 indexed claimId,\r\n        uint256 indexed programsId,\r\n        address indexed farmer,\r\n        uint256 amount\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyGovernment() {\r\n        require(\r\n            msg.sender == owner || isGovernment[msg.sender],\r\n            \"Not government\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyOracle() {\r\n        require(msg.sender == oracle || msg.sender == owner, \"Not oracle\");\r\n        _;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(!reentrancyLock, \"Reentrancy blocked\");\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n    constructor(address initialOracle) {\r\n        owner = msg.sender;\r\n        isGovernment[msg.sender] = true;\r\n        oracle = initialOracle;\r\n        emit OwnerUpdated(msg.sender);\r\n        emit GovernmentRoleGranted(msg.sender);\r\n        emit OracleUpdated(initialOracle);\r\n    }\r\n\r\n    // ---- Admin/oracle management ----\r\n\r\n    function updateOwner(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"Zero owner\");\r\n        owner = newOwner;\r\n        emit OwnerUpdated(newOwner);\r\n    }\r\n\r\n    /// @notice Grant government role to an address.\r\n    function grantGovernmentRole(address account) external onlyOwner {\r\n        require(account != address(0), \"Zero account\");\r\n        require(!isGovernment[account], \"Already government\");\r\n        isGovernment[account] = true;\r\n        emit GovernmentRoleGranted(account);\r\n    }\r\n\r\n    /// @notice Revoke government role from an address (owner remains implicit government).\r\n    function revokeGovernmentRole(address account) external onlyOwner {\r\n        require(account != address(0), \"Zero account\");\r\n        require(account != owner, \"Cannot revoke owner\");\r\n        require(isGovernment[account], \"Not government\");\r\n        isGovernment[account] = false;\r\n        emit GovernmentRoleRevoked(account);\r\n    }\r\n\r\n    function updateOracle(address newOracle) external onlyOwner {\r\n        require(newOracle != address(0), \"Zero oracle\");\r\n        oracle = newOracle;\r\n        emit OracleUpdated(newOracle);\r\n    }\r\n\r\n    // ---- Funding ----\r\n\r\n    /// @notice Deposit funds to agency's internal balance\r\n    function deposit() external payable {\r\n        require(msg.value > 0, \"No ETH\");\r\n        agencyFunds[msg.sender] += msg.value;\r\n        emit ContractFunded(msg.sender, msg.value);\r\n        emit FundsDeposited(msg.sender, msg.value);\r\n    }\r\n\r\n    receive() external payable {\r\n        agencyFunds[msg.sender] += msg.value;\r\n        emit ContractFunded(msg.sender, msg.value);\r\n        emit FundsDeposited(msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice Get agency's internal balance\r\n    function getAgencyBalance(address agency) external view returns (uint256) {\r\n        return agencyFunds[agency];\r\n    }\r\n\r\n    // ---- Program lifecycle ----\r\n\r\n    function createProgram(\r\n        string calldata name,\r\n        string calldata description,\r\n        ProgramType programsType,\r\n        ProgramStatus status,\r\n        uint256 startDate,\r\n        uint256 endDate,\r\n        string calldata createdBy,\r\n        bytes32 metadataHash,\r\n        PayoutRule calldata payoutRule,\r\n        Eligibility calldata eligibility\r\n    ) external returns (uint256 programsId) {\r\n        require(bytes(name).length > 0, \"Name required\");\r\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\r\n        require(startDate < endDate, \"Invalid dates\");\r\n\r\n        programsId = nextProgramId++;\r\n\r\n        // store eligibility arrays in memory to storage\r\n        Eligibility storage e = programs[programsId].eligibility;\r\n        _setEligibility(e, eligibility);\r\n\r\n        programs[programsId].name = name;\r\n        programs[programsId].description = description;\r\n        programs[programsId].programsType = programsType;\r\n        programs[programsId].status = status;\r\n        programs[programsId].startDate = startDate;\r\n        programs[programsId].endDate = endDate;\r\n        programs[programsId].createdBy = createdBy;\r\n        programs[programsId].metadataHash = metadataHash;\r\n        programs[programsId].payoutRule = payoutRule;\r\n        programs[programsId].totalDisbursed = 0;\r\n\r\n        emit ProgramCreated(\r\n            programsId,\r\n            name,\r\n            programsType,\r\n            status,\r\n            startDate,\r\n            endDate,\r\n            metadataHash,\r\n            payoutRule.amount,\r\n            payoutRule.maxCap\r\n        );\r\n    }\r\n\r\n    function updateProgramStatus(\r\n        uint256 programsId,\r\n        ProgramStatus status\r\n    ) external {\r\n        Program storage p = programs[programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        p.status = status;\r\n        emit ProgramStatusUpdated(programsId, status);\r\n    }\r\n\r\n    function updatePayoutRule(\r\n        uint256 programsId,\r\n        PayoutRule calldata payoutRule\r\n    ) external {\r\n        Program storage p = programs[programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\r\n        p.payoutRule = payoutRule;\r\n        emit ProgramUpdated(programsId, payoutRule.amount, payoutRule.maxCap);\r\n    }\r\n\r\n    function updateEligibility(\r\n        uint256 programsId,\r\n        Eligibility calldata eligibility\r\n    ) external {\r\n        Program storage p = programs[programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        _clearEligibilityArrays(p.eligibility);\r\n        _setEligibility(p.eligibility, eligibility);\r\n        emit EligibilityUpdated(programsId);\r\n    }\r\n\r\n    // ---- Claims ----\r\n\r\n    /// @notice Farmer opts into a programs before any automated claim generation.\r\n    function enrollInProgram(uint256 programsId) external {\r\n        Program storage p = programs[programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program not active\");\r\n        require(block.timestamp <= p.endDate, \"Program ended\");\r\n        require(!isFarmerEnrolled[programsId][msg.sender], \"Already enrolled\");\r\n\r\n        isFarmerEnrolled[programsId][msg.sender] = true;\r\n        enrolledPrograms[msg.sender].push(programsId);\r\n        emit FarmerEnrolled(msg.sender, programsId);\r\n    }\r\n\r\n    /// @notice Farmers submit a claim for a programs; amount is derived from programs payout rule.\r\n    function submitClaim(\r\n        uint256 programsId,\r\n        bytes32 metadataHash\r\n    ) external returns (uint256 claimId) {\r\n        Program storage p = programs[programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\r\n        require(\r\n            block.timestamp >= p.startDate && block.timestamp <= p.endDate,\r\n            \"Outside window\"\r\n        );\r\n        require(\r\n            isFarmerEnrolled[programsId][msg.sender],\r\n            \"Farmer not enrolled\"\r\n        );\r\n\r\n        claimId = nextClaimId++;\r\n        claims[claimId] = Claim({\r\n            programsId: programsId,\r\n            farmer: msg.sender,\r\n            amount: p.payoutRule.amount,\r\n            status: ClaimStatus.PendingReview,\r\n            metadataHash: metadataHash,\r\n            submittedAt: block.timestamp,\r\n            rejectionReason: \"\"\r\n        });\r\n\r\n        emit ClaimSubmitted(\r\n            claimId,\r\n            programsId,\r\n            msg.sender,\r\n            p.payoutRule.amount,\r\n            metadataHash\r\n        );\r\n    }\r\n\r\n    /// @notice Oracle automation creates claims for all enrolled farmers when the hazard trigger occurs.\r\n    function autoCreateClaim(\r\n        uint256 programsId,\r\n        address farmer,\r\n        bytes32 metadataHash\r\n    ) external onlyOracle returns (uint256 claimId) {\r\n        Program storage p = programs[programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\r\n        require(\r\n            block.timestamp >= p.startDate && block.timestamp <= p.endDate,\r\n            \"Outside window\"\r\n        );\r\n        require(isFarmerEnrolled[programsId][farmer], \"Farmer not enrolled\");\r\n\r\n        claimId = nextClaimId++;\r\n        claims[claimId] = Claim({\r\n            programsId: programsId,\r\n            farmer: farmer,\r\n            amount: p.payoutRule.amount,\r\n            status: ClaimStatus.PendingReview,\r\n            metadataHash: metadataHash,\r\n            submittedAt: block.timestamp,\r\n            rejectionReason: \"\"\r\n        });\r\n\r\n        emit ClaimSubmitted(\r\n            claimId,\r\n            programsId,\r\n            farmer,\r\n            p.payoutRule.amount,\r\n            metadataHash\r\n        );\r\n        emit AutoClaimCreated(claimId, programsId, farmer);\r\n    }\r\n\r\n    /// @notice Oracle approves and pays out a claim in a single step (kept for backward compatibility).\r\n    /// @notice Note: For new implementations, use approveClaim() then disburseClaim() separately.\r\n    function approveAndPayout(\r\n        uint256 claimId\r\n    ) external onlyOracle nonReentrant {\r\n        Claim storage c = claims[claimId];\r\n        require(c.status == ClaimStatus.PendingReview, \"Must be pending\");\r\n        Program storage p = programs[c.programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\r\n        // Oracle uses contract balance, not agency funds\r\n        require(\r\n            address(this).balance >= c.amount,\r\n            \"Insufficient contract balance\"\r\n        );\r\n\r\n        // Approve first\r\n        c.status = ClaimStatus.Approved;\r\n        emit ClaimApproved(claimId, c.programsId, c.farmer, c.amount);\r\n\r\n        // Then disburse\r\n        _payoutApprovedClaim(claimId, c, p, address(0));\r\n        emit ClaimDisbursed(claimId, c.programsId, c.farmer, c.amount);\r\n    }\r\n\r\n    /// @notice Reject a claim (archives it by changing status to Rejected)\r\n    /// @param claimId The ID of the claim to reject\r\n    /// @param reason The reason for rejection\r\n    function rejectClaim(\r\n        uint256 claimId,\r\n        string calldata reason\r\n    ) external {\r\n        Claim storage c = claims[claimId];\r\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\r\n        c.status = ClaimStatus.Rejected;\r\n        c.rejectionReason = reason;\r\n        emit ClaimRejected(claimId, c.programsId, c.farmer, reason);\r\n    }\r\n\r\n    /// @notice Approve a claim (changes status to Approved, does NOT disburse funds)\r\n    /// @param claimId The ID of the claim to approve\r\n    function approveClaim(uint256 claimId) external {\r\n        Claim storage c = claims[claimId];\r\n        require(c.status == ClaimStatus.PendingReview, \"Claim must be pending\");\r\n        Program storage p = programs[c.programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\r\n\r\n        c.status = ClaimStatus.Approved;\r\n        emit ClaimApproved(claimId, c.programsId, c.farmer, c.amount);\r\n    }\r\n\r\n    /// @notice Disburse funds for an approved claim\r\n    /// @param claimId The ID of the approved claim to disburse\r\n    function disburseClaim(\r\n        uint256 claimId\r\n    ) external nonReentrant {\r\n        Claim storage c = claims[claimId];\r\n        require(c.status == ClaimStatus.Approved, \"Claim must be approved\");\r\n\r\n        Program storage p = programs[c.programsId];\r\n        require(bytes(p.name).length != 0, \"Program missing\");\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\r\n\r\n        // Check if agency has sufficient funds (government can use their agency funds)\r\n        require(\r\n            agencyFunds[msg.sender] >= c.amount,\r\n            \"Agency insufficient balance\"\r\n        );\r\n\r\n        _payoutApprovedClaim(claimId, c, p, msg.sender);\r\n        emit ClaimDisbursed(claimId, c.programsId, c.farmer, c.amount);\r\n    }\r\n\r\n    // ---- Views ----\r\n\r\n    function getProgram(\r\n        uint256 programsId\r\n    ) external view returns (Program memory) {\r\n        return programs[programsId];\r\n    }\r\n\r\n    function getClaim(uint256 claimId) external view returns (Claim memory) {\r\n        return claims[claimId];\r\n    }\r\n\r\n    // ---- internal helpers ----\r\n\r\n    function _payoutApprovedClaim(\r\n        uint256 claimId,\r\n        Claim storage c,\r\n        Program storage p,\r\n        address agency\r\n    ) private {\r\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\r\n        if (p.payoutRule.maxCap > 0) {\r\n            require(\r\n                p.totalDisbursed + c.amount <= p.payoutRule.maxCap,\r\n                \"Program cap exceeded\"\r\n            );\r\n        }\r\n\r\n        // If agency is provided, use agency funds; otherwise use contract balance (for oracle)\r\n        if (agency != address(0)) {\r\n            require(\r\n                agencyFunds[agency] >= c.amount,\r\n                \"Agency insufficient balance\"\r\n            );\r\n            agencyFunds[agency] -= c.amount;\r\n        } else {\r\n            require(\r\n                address(this).balance >= c.amount,\r\n                \"Insufficient contract balance\"\r\n            );\r\n        }\r\n\r\n        p.totalDisbursed += c.amount;\r\n        c.status = ClaimStatus.Paid;\r\n\r\n        (bool ok, ) = c.farmer.call{value: c.amount}(\"\");\r\n        require(ok, \"Transfer failed\");\r\n\r\n        emit ClaimPaid(claimId, c.programsId, c.farmer, c.amount);\r\n    }\r\n\r\n    function _setEligibility(\r\n        Eligibility storage dest,\r\n        Eligibility calldata src\r\n    ) private {\r\n        dest.hasMinFarmSize = src.hasMinFarmSize;\r\n        dest.hasMaxFarmSize = src.hasMaxFarmSize;\r\n        dest.minFarmSize = src.minFarmSize;\r\n        dest.maxFarmSize = src.maxFarmSize;\r\n\r\n        for (uint256 i = 0; i < src.states.length; i++) {\r\n            dest.states.push(src.states[i]);\r\n        }\r\n        for (uint256 i = 0; i < src.districts.length; i++) {\r\n            dest.districts.push(src.districts[i]);\r\n        }\r\n        for (uint256 i = 0; i < src.cropTypes.length; i++) {\r\n            dest.cropTypes.push(src.cropTypes[i]);\r\n        }\r\n        for (uint256 i = 0; i < src.certifications.length; i++) {\r\n            dest.certifications.push(src.certifications[i]);\r\n        }\r\n    }\r\n\r\n    function _clearEligibilityArrays(Eligibility storage e) private {\r\n        delete e.states;\r\n        delete e.districts;\r\n        delete e.cropTypes;\r\n        delete e.certifications;\r\n    }\r\n}\r\n"
      }
    }
  }
}