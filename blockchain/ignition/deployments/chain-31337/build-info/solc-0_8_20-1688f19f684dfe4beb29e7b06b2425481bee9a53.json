{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-1688f19f684dfe4beb29e7b06b2425481bee9a53",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/SubsidyPayoutOracleConsumer.sol": "project/contracts/SubsidyPayoutOracleConsumer.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.5.0/",
        "project/:@chainlink/contracts/=npm/@chainlink/contracts@1.5.0/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@chainlink/contracts@1.5.0/src/v0.8/functions/v1_0_0/FunctionsClient.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(\n    address router\n  ) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId =\n      i_router.sendRequest(subscriptionId, data, FunctionsRequest.REQUEST_DATA_VERSION, callbackGasLimit, donId);\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
      },
      "npm/@chainlink/contracts@1.5.0/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
      },
      "npm/@chainlink/contracts@1.5.0/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(\n    bytes32 allowListId\n  ) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(\n    bytes32 id\n  ) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(\n    bytes32 id\n  ) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
      },
      "npm/@chainlink/contracts@1.5.0/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n\n  }\n\n  enum CodeLanguage {\n    JavaScript\n  }\n  // In future version we may add other languages\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be\n      // executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the\n      // source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for\n      // Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal\n      // number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use\n      // addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use\n      // addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(\n    Request memory self\n  ) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
      },
      "npm/@chainlink/contracts@1.5.0/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request\n      // data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the\n      // Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the\n      // Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to\n      // fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that\n      // will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for\n      // servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
      },
      "npm/@chainlink/contracts@1.5.0/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
        "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
      },
      "npm/@chainlink/contracts@1.5.0/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
      },
      "project/contracts/SubsidyPayout.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SubsidyPayout - Automated subsidy disbursement aligned with programs schema\n/// @notice Mirrors the backend programs schema (programs, eligibility, payout rule) and executes payouts once an oracle approves claims.\ncontract SubsidyPayout {\n    enum ProgramType {\n        DROUGHT,\n        FLOOD,\n        CROP_LOSS,\n        MANUAL\n    }\n\n    enum ProgramStatus {\n        DRAFT,\n        ACTIVE,\n        ARCHIVED\n    }\n\n    enum ClaimStatus {\n        PendingReview,\n        Approved,\n        Rejected,\n        Paid\n    }\n\n    struct Eligibility {\n        bool hasMinFarmSize;\n        bool hasMaxFarmSize;\n        uint256 minFarmSize;\n        uint256 maxFarmSize;\n        string[] states;\n        string[] districts;\n        string[] cropTypes;\n        string[] certifications;\n    }\n\n    struct PayoutRule {\n        uint256 amount; // fixed payout per claim (wei)\n        uint256 maxCap; // total cap for the programs (0 = uncapped)\n    }\n\n    struct Program {\n        string name;\n        string description;\n        ProgramType programsType;\n        ProgramStatus status;\n        uint256 startDate;\n        uint256 endDate;\n        string createdBy; // mirrors prisma createdBy string\n        bytes32 metadataHash; // hash/pointer to full off-chain programs config\n        PayoutRule payoutRule;\n        Eligibility eligibility;\n        uint256 totalDisbursed;\n    }\n\n    struct Claim {\n        uint256 programsId;\n        address farmer;\n        uint256 amount;\n        ClaimStatus status;\n        bytes32 metadataHash; // hash/pointer to off-chain claim metadata\n        uint256 submittedAt;\n        string rejectionReason;\n    }\n\n    address public owner;\n    address public oracle; // trusted oracle/approver for automatic payouts\n    mapping(address => bool) public isGovernment; // multiple government addresses\n\n    uint256 public nextProgramId = 1;\n    uint256 public nextClaimId = 1;\n\n    mapping(uint256 => Program) public programs;\n    mapping(uint256 => Claim) public claims;\n    mapping(address => uint256[]) public enrolledPrograms; // farmer => list of programsIds\n    mapping(uint256 => mapping(address => bool)) public isFarmerEnrolled; // programsId => farmer enrolled\n\n    bool private reentrancyLock;\n\n    event OwnerUpdated(address indexed owner);\n    event OracleUpdated(address indexed oracle);\n    event GovernmentRoleGranted(address indexed account);\n    event GovernmentRoleRevoked(address indexed account);\n    event FundsDeposited(address indexed from, uint256 amount);\n    event ProgramCreated(\n        uint256 indexed programsId,\n        string name,\n        ProgramType programsType,\n        ProgramStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        bytes32 metadataHash,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap\n    );\n    event ProgramStatusUpdated(\n        uint256 indexed programsId,\n        ProgramStatus status\n    );\n    event ProgramUpdated(\n        uint256 indexed programsId,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap\n    );\n    event EligibilityUpdated(uint256 indexed programsId);\n    event ClaimSubmitted(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        uint256 amount,\n        bytes32 metadataHash\n    );\n    event FarmerEnrolled(address indexed farmer, uint256 indexed programsId);\n    event AutoClaimCreated(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer\n    );\n    event ClaimApproved(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        uint256 amount\n    );\n    event ClaimPaid(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        uint256 amount\n    );\n    event ClaimRejected(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        string reason\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyGovernment() {\n        require(\n            msg.sender == owner || isGovernment[msg.sender],\n            \"Not government\"\n        );\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle || msg.sender == owner, \"Not oracle\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(!reentrancyLock, \"Reentrancy blocked\");\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n    constructor(address initialOracle) {\n        owner = msg.sender;\n        isGovernment[msg.sender] = true;\n        oracle = initialOracle;\n        emit OwnerUpdated(msg.sender);\n        emit GovernmentRoleGranted(msg.sender);\n        emit OracleUpdated(initialOracle);\n    }\n\n    // ---- Admin/oracle management ----\n\n    function updateOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Zero owner\");\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @notice Grant government role to an address.\n    function grantGovernmentRole(address account) external onlyOwner {\n        require(account != address(0), \"Zero account\");\n        require(!isGovernment[account], \"Already government\");\n        isGovernment[account] = true;\n        emit GovernmentRoleGranted(account);\n    }\n\n    /// @notice Revoke government role from an address (owner remains implicit government).\n    function revokeGovernmentRole(address account) external onlyOwner {\n        require(account != address(0), \"Zero account\");\n        require(account != owner, \"Cannot revoke owner\");\n        require(isGovernment[account], \"Not government\");\n        isGovernment[account] = false;\n        emit GovernmentRoleRevoked(account);\n    }\n\n    function updateOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"Zero oracle\");\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    // ---- Funding ----\n\n    function deposit() external payable {\n        require(msg.value > 0, \"No value\");\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    receive() external payable {\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    // ---- Program lifecycle ----\n\n    function createProgram(\n        string calldata name,\n        string calldata description,\n        ProgramType programsType,\n        ProgramStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        string calldata createdBy,\n        bytes32 metadataHash,\n        PayoutRule calldata payoutRule,\n        Eligibility calldata eligibility\n    ) external returns (uint256 programsId) {\n        require(bytes(name).length > 0, \"Name required\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        require(startDate < endDate, \"Invalid dates\");\n\n        programsId = nextProgramId++;\n\n        // store eligibility arrays in memory to storage\n        Eligibility storage e = programs[programsId].eligibility;\n        _setEligibility(e, eligibility);\n\n        programs[programsId].name = name;\n        programs[programsId].description = description;\n        programs[programsId].programsType = programsType;\n        programs[programsId].status = status;\n        programs[programsId].startDate = startDate;\n        programs[programsId].endDate = endDate;\n        programs[programsId].createdBy = createdBy;\n        programs[programsId].metadataHash = metadataHash;\n        programs[programsId].payoutRule = payoutRule;\n        programs[programsId].totalDisbursed = 0;\n\n        emit ProgramCreated(\n            programsId,\n            name,\n            programsType,\n            status,\n            startDate,\n            endDate,\n            metadataHash,\n            payoutRule.amount,\n            payoutRule.maxCap\n        );\n    }\n\n    function updateProgramStatus(\n        uint256 programsId,\n        ProgramStatus status\n    ) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        p.status = status;\n        emit ProgramStatusUpdated(programsId, status);\n    }\n\n    function updatePayoutRule(\n        uint256 programsId,\n        PayoutRule calldata payoutRule\n    ) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        p.payoutRule = payoutRule;\n        emit ProgramUpdated(programsId, payoutRule.amount, payoutRule.maxCap);\n    }\n\n    function updateEligibility(\n        uint256 programsId,\n        Eligibility calldata eligibility\n    ) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        _clearEligibilityArrays(p.eligibility);\n        _setEligibility(p.eligibility, eligibility);\n        emit EligibilityUpdated(programsId);\n    }\n\n    // ---- Claims ----\n\n    /// @notice Farmer opts into a programs before any automated claim generation.\n    function enrollInProgram(uint256 programsId) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(p.status == ProgramStatus.ACTIVE, \"Program not active\");\n        require(block.timestamp <= p.endDate, \"Program ended\");\n        require(!isFarmerEnrolled[programsId][msg.sender], \"Already enrolled\");\n\n        isFarmerEnrolled[programsId][msg.sender] = true;\n        enrolledPrograms[msg.sender].push(programsId);\n        emit FarmerEnrolled(msg.sender, programsId);\n    }\n\n    /// @notice Farmers submit a claim for a programs; amount is derived from programs payout rule.\n    function submitClaim(\n        uint256 programsId,\n        bytes32 metadataHash\n    ) external returns (uint256 claimId) {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        require(\n            block.timestamp >= p.startDate && block.timestamp <= p.endDate,\n            \"Outside window\"\n        );\n        require(\n            isFarmerEnrolled[programsId][msg.sender],\n            \"Farmer not enrolled\"\n        );\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            programsId: programsId,\n            farmer: msg.sender,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.PendingReview,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(\n            claimId,\n            programsId,\n            msg.sender,\n            p.payoutRule.amount,\n            metadataHash\n        );\n    }\n\n    /// @notice Oracle automation creates claims for all enrolled farmers when the hazard trigger occurs.\n    function autoCreateClaim(\n        uint256 programsId,\n        address farmer,\n        bytes32 metadataHash\n    ) external onlyOracle returns (uint256 claimId) {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        require(\n            block.timestamp >= p.startDate && block.timestamp <= p.endDate,\n            \"Outside window\"\n        );\n        require(isFarmerEnrolled[programsId][farmer], \"Farmer not enrolled\");\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            programsId: programsId,\n            farmer: farmer,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.PendingReview,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(\n            claimId,\n            programsId,\n            farmer,\n            p.payoutRule.amount,\n            metadataHash\n        );\n        emit AutoClaimCreated(claimId, programsId, farmer);\n    }\n\n    /// @notice Oracle approves and pays out a claim in a single step (kept for compatibility).\n    function approveAndPayout(\n        uint256 claimId\n    ) external onlyOracle nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.Approved, \"Not approved\");\n        Program storage p = programs[c.programsId];\n        _payoutApprovedClaim(claimId, c, p);\n    }\n\n    function rejectClaim(uint256 claimId, string calldata reason) external {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\n        c.status = ClaimStatus.Rejected;\n        c.rejectionReason = reason;\n        emit ClaimRejected(claimId, c.programsId, c.farmer, reason);\n    }\n\n    function approveClaim(uint256 claimId) external nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\n        Program storage p = programs[c.programsId];\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        c.status = ClaimStatus.Approved;\n        emit ClaimApproved(claimId, c.programsId, c.farmer, c.amount);\n        _payoutApprovedClaim(claimId, c, p);\n    }\n\n    // ---- Views ----\n\n    function getProgram(\n        uint256 programsId\n    ) external view returns (Program memory) {\n        return programs[programsId];\n    }\n\n    function getClaim(uint256 claimId) external view returns (Claim memory) {\n        return claims[claimId];\n    }\n\n    // ---- internal helpers ----\n\n    function _payoutApprovedClaim(\n        uint256 claimId,\n        Claim storage c,\n        Program storage p\n    ) private {\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        if (p.payoutRule.maxCap > 0) {\n            require(\n                p.totalDisbursed + c.amount <= p.payoutRule.maxCap,\n                \"Program cap exceeded\"\n            );\n        }\n        require(\n            address(this).balance >= c.amount,\n            \"Insufficient contract balance\"\n        );\n\n        p.totalDisbursed += c.amount;\n        c.status = ClaimStatus.Paid;\n\n        (bool ok, ) = c.farmer.call{value: c.amount}(\"\");\n        require(ok, \"Transfer failed\");\n\n        emit ClaimPaid(claimId, c.programsId, c.farmer, c.amount);\n    }\n\n    function _setEligibility(\n        Eligibility storage dest,\n        Eligibility calldata src\n    ) private {\n        dest.hasMinFarmSize = src.hasMinFarmSize;\n        dest.hasMaxFarmSize = src.hasMaxFarmSize;\n        dest.minFarmSize = src.minFarmSize;\n        dest.maxFarmSize = src.maxFarmSize;\n\n        for (uint256 i = 0; i < src.states.length; i++) {\n            dest.states.push(src.states[i]);\n        }\n        for (uint256 i = 0; i < src.districts.length; i++) {\n            dest.districts.push(src.districts[i]);\n        }\n        for (uint256 i = 0; i < src.cropTypes.length; i++) {\n            dest.cropTypes.push(src.cropTypes[i]);\n        }\n        for (uint256 i = 0; i < src.certifications.length; i++) {\n            dest.certifications.push(src.certifications[i]);\n        }\n    }\n\n    function _clearEligibilityArrays(Eligibility storage e) private {\n        delete e.states;\n        delete e.districts;\n        delete e.cropTypes;\n        delete e.certifications;\n    }\n}\n"
      },
      "project/contracts/SubsidyPayoutOracleConsumer.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {\n    FunctionsClient\n} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol\";\nimport {\n    FunctionsRequest\n} from \"@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol\";\n\nimport \"./SubsidyPayout.sol\";\n\n/// @title SubsidyPayoutOracleConsumer\n/// @notice Uses Chainlink Functions to call the official flood-warning API and auto-create claims for enrolled farmers when danger thresholds are met. A separate call is used to pay approved claims.\n/// @dev Set this contract as `oracle` on SubsidyPayout so it can create claims and execute payouts.\ncontract SubsidyPayoutOracleConsumer is FunctionsClient {\n    using FunctionsRequest for FunctionsRequest.Request;\n\n    struct PendingRequest {\n        uint256 programsId;\n        address farmer;\n        string state;\n        string district;\n        string stationId;\n        bytes32 metadataHash;\n        bool exists;\n    }\n\n    address public owner;\n    SubsidyPayout public payout;\n\n    address public automationCaller; // authorized Chainlink Automation forwarder\n    uint256 public autoProgramId;\n    address public autoFarmer;\n    string public autoState;\n    string public autoDistrict;\n    string public autoStationId;\n    bytes32 public autoMetadataHash;\n\n    uint64 public subscriptionId;\n    bytes32 public donId;\n    uint32 public gasLimit = 300000;\n    string public source; // inline JS for Chainlink Functions\n\n    mapping(bytes32 => PendingRequest) public pendingRequests;\n\n    event OwnerUpdated(address indexed newOwner);\n    event AutomationCallerUpdated(address indexed newCaller);\n    event AutomationConfigUpdated(\n        uint256 programsId,\n        address farmer,\n        string state,\n        string district,\n        string stationId,\n        bytes32 metadataHash\n    );\n    event ConfigUpdated(uint64 subscriptionId, bytes32 donId, uint32 gasLimit);\n    event SourceUpdated(string source);\n    event WaterLevelCheckRequested(\n        bytes32 indexed requestId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        string state,\n        string district,\n        string stationId,\n        bytes32 metadataHash\n    );\n    event WaterLevelCheckFulfilled(\n        bytes32 indexed requestId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        string state,\n        string district,\n        string stationId,\n        uint256 waterLevelCurrent,\n        uint256 waterLevelDanger,\n        bool triggered,\n        bool enrolled,\n        uint256 claimId\n    );\n    event AutoClaimCreationFailed(\n        bytes32 indexed requestId,\n        uint256 indexed programsId,\n        address indexed farmer\n    );\n    event WaterLevelCheckErrored(bytes32 indexed requestId, bytes error);\n    event ApprovedPayoutExecuted(uint256 indexed claimId);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    constructor(\n        address router,\n        address payable payoutContract,\n        uint64 functionsSubscriptionId,\n        bytes32 functionsDonId,\n        string memory defaultSource\n    ) FunctionsClient(router) {\n        owner = msg.sender;\n        payout = SubsidyPayout(payoutContract);\n        subscriptionId = functionsSubscriptionId;\n        donId = functionsDonId;\n        source = defaultSource;\n        emit OwnerUpdated(msg.sender);\n        emit AutomationCallerUpdated(address(0));\n        emit AutomationConfigUpdated(0, address(0), \"\", \"\", \"\", 0);\n        emit ConfigUpdated(subscriptionId, donId, gasLimit);\n        emit SourceUpdated(defaultSource);\n    }\n\n    /// @notice Update Chainlink Functions config.\n    function updateConfig(\n        uint64 functionsSubscriptionId,\n        bytes32 functionsDonId,\n        uint32 functionsGasLimit\n    ) external onlyOwner {\n        subscriptionId = functionsSubscriptionId;\n        donId = functionsDonId;\n        gasLimit = functionsGasLimit;\n        emit ConfigUpdated(subscriptionId, donId, gasLimit);\n    }\n\n    /// @notice Update the JS source used by Chainlink Functions.\n    function updateSource(string calldata newSource) external onlyOwner {\n        source = newSource;\n        emit SourceUpdated(newSource);\n    }\n\n    /// @notice Configure which programs/claim/state/station should be used by Automation performUpkeep.\n    function updateAutomationConfig(\n        uint256 programsId,\n        address farmer,\n        string calldata state,\n        string calldata district,\n        string calldata stationId,\n        bytes32 metadataHash\n    ) external onlyOwner {\n        require(bytes(state).length != 0, \"State required\");\n        require(bytes(district).length != 0, \"District required\");\n        require(bytes(stationId).length != 0, \"Station required\");\n        require(farmer != address(0), \"Farmer required\");\n        require(\n            payout.isFarmerEnrolled(programsId, farmer),\n            \"Farmer not enrolled\"\n        );\n        autoProgramId = programsId;\n        autoFarmer = farmer;\n        autoState = state;\n        autoDistrict = district;\n        autoStationId = stationId;\n        autoMetadataHash = metadataHash;\n        emit AutomationConfigUpdated(\n            programsId,\n            farmer,\n            state,\n            district,\n            stationId,\n            metadataHash\n        );\n    }\n\n    /// @notice Authorize the Automation caller (e.g. Chainlink Automation forwarder).\n    function updateAutomationCaller(address newCaller) external onlyOwner {\n        require(newCaller != address(0), \"Zero caller\");\n        automationCaller = newCaller;\n        emit AutomationCallerUpdated(newCaller);\n    }\n\n    /// @notice Automation entrypoint; triggers the configured programs/claim check.\n    /// @dev Meant for Chainlink Automation; reuses requestWaterLevelCheck logic.\n    function performUpkeep(bytes calldata) external {\n        require(\n            msg.sender == automationCaller || msg.sender == owner,\n            \"Not automation\"\n        );\n        require(\n            autoProgramId != 0 && autoFarmer != address(0),\n            \"Automation config missing\"\n        );\n        require(\n            bytes(autoState).length != 0 &&\n                bytes(autoDistrict).length != 0 &&\n                bytes(autoStationId).length != 0,\n            \"Automation location missing\"\n        );\n        _requestWaterLevelCheck(\n            autoProgramId,\n            autoFarmer,\n            autoState,\n            autoDistrict,\n            autoStationId,\n            autoMetadataHash\n        );\n    }\n\n    /// @notice Request a water level danger check; if the API reports danger level reached, this contract will auto-create a claim for the enrolled farmer.\n    /// @dev Ensure this contract is set as `oracle` in SubsidyPayout.\n    function requestWaterLevelCheck(\n        uint256 programsId,\n        address farmer,\n        string calldata state,\n        string calldata district,\n        string calldata stationId,\n        bytes32 metadataHash\n    ) external onlyOwner returns (bytes32 requestId) {\n        return\n            _requestWaterLevelCheck(\n                programsId,\n                farmer,\n                state,\n                district,\n                stationId,\n                metadataHash\n            );\n    }\n\n    function _requestWaterLevelCheck(\n        uint256 programsId,\n        address farmer,\n        string memory state,\n        string memory district,\n        string memory stationId,\n        bytes32 metadataHash\n    ) internal returns (bytes32 requestId) {\n        SubsidyPayout.Program memory programs = payout.getProgram(programsId);\n        require(bytes(programs.name).length != 0, \"Program missing\");\n        require(\n            programs.status == SubsidyPayout.ProgramStatus.ACTIVE,\n            \"Program inactive\"\n        );\n        require(bytes(state).length != 0, \"State required\");\n        require(bytes(district).length != 0, \"District required\");\n        require(bytes(stationId).length != 0, \"Station required\");\n        require(farmer != address(0), \"Farmer required\");\n        require(\n            payout.isFarmerEnrolled(programsId, farmer),\n            \"Farmer not enrolled\"\n        );\n\n        FunctionsRequest.Request memory req;\n        req.initializeRequestForInlineJavaScript(source);\n        string[] memory args = new string[](3);\n        args[0] = state;\n        args[1] = district;\n        args[2] = stationId;\n        req.setArgs(args);\n\n        requestId = _sendRequest(\n            req.encodeCBOR(),\n            subscriptionId,\n            gasLimit,\n            donId\n        );\n        pendingRequests[requestId] = PendingRequest({\n            programsId: programsId,\n            farmer: farmer,\n            state: state,\n            district: district,\n            stationId: stationId,\n            metadataHash: metadataHash,\n            exists: true\n        });\n\n        emit WaterLevelCheckRequested(\n            requestId,\n            programsId,\n            farmer,\n            state,\n            district,\n            stationId,\n            metadataHash\n        );\n    }\n\n    /// @notice Chainlink Functions fulfillment callback.\n    function fulfillRequest(\n        bytes32 requestId,\n        bytes memory response,\n        bytes memory err\n    ) internal override {\n        PendingRequest memory pending = pendingRequests[requestId];\n        require(pending.exists, \"Unknown request\");\n        delete pendingRequests[requestId];\n\n        if (err.length > 0) {\n            emit WaterLevelCheckErrored(requestId, err);\n            return;\n        }\n\n        // Values are scaled by 1e2 in the JS source to retain two decimals.\n        (\n            uint256 waterLevelCurrentTimes100,\n            uint256 waterLevelDangerTimes100\n        ) = abi.decode(response, (uint256, uint256));\n        bool triggered = waterLevelDangerTimes100 > 0 &&\n            waterLevelCurrentTimes100 >= waterLevelDangerTimes100;\n        bool enrolled = payout.isFarmerEnrolled(\n            pending.programsId,\n            pending.farmer\n        );\n        uint256 claimId = 0;\n\n        if (triggered && enrolled) {\n            try\n                payout.autoCreateClaim(\n                    pending.programsId,\n                    pending.farmer,\n                    pending.metadataHash\n                )\n            returns (uint256 newClaimId) {\n                claimId = newClaimId;\n            } catch {\n                emit AutoClaimCreationFailed(\n                    requestId,\n                    pending.programsId,\n                    pending.farmer\n                );\n            }\n        }\n\n        emit WaterLevelCheckFulfilled(\n            requestId,\n            pending.programsId,\n            pending.farmer,\n            pending.state,\n            pending.district,\n            pending.stationId,\n            waterLevelCurrentTimes100,\n            waterLevelDangerTimes100,\n            triggered,\n            enrolled,\n            claimId\n        );\n    }\n\n    /// @notice Execute payout for an already approved claim (government-approved).\n    /// @dev This contract must remain set as the oracle on SubsidyPayout.\n    function executeApprovedPayout(uint256 claimId) external {\n        require(\n            msg.sender == automationCaller || msg.sender == owner,\n            \"Not authorized\"\n        );\n        payout.approveAndPayout(claimId);\n        emit ApprovedPayoutExecuted(claimId);\n    }\n}\n"
      }
    }
  }
}