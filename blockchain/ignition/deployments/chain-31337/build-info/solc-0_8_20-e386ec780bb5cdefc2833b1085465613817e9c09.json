{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-e386ec780bb5cdefc2833b1085465613817e9c09",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/SubsidyPayout.sol": "project/contracts/SubsidyPayout.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/SubsidyPayout.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SubsidyPayout - Automated subsidy disbursement aligned with programs schema\n/// @notice Mirrors the backend programs schema (programs, eligibility, payout rule) and executes payouts once an oracle approves claims.\ncontract SubsidyPayout {\n    enum ProgramType {\n        DROUGHT,\n        FLOOD,\n        CROP_LOSS,\n        MANUAL\n    }\n\n    enum ProgramStatus {\n        DRAFT,\n        ACTIVE,\n        ARCHIVED\n    }\n\n    enum ClaimStatus {\n        PendingReview,\n        Approved,\n        Rejected,\n        Paid\n    }\n\n    struct Eligibility {\n        bool hasMinFarmSize;\n        bool hasMaxFarmSize;\n        uint256 minFarmSize;\n        uint256 maxFarmSize;\n        string[] states;\n        string[] districts;\n        string[] cropTypes;\n        string[] certifications;\n    }\n\n    struct PayoutRule {\n        uint256 amount; // fixed payout per claim (wei)\n        uint256 maxCap; // total cap for the programs (0 = uncapped)\n    }\n\n    struct Program {\n        string name;\n        string description;\n        ProgramType programsType;\n        ProgramStatus status;\n        uint256 startDate;\n        uint256 endDate;\n        string createdBy; // mirrors prisma createdBy string\n        bytes32 metadataHash; // hash/pointer to full off-chain programs config\n        PayoutRule payoutRule;\n        Eligibility eligibility;\n        uint256 totalDisbursed;\n    }\n\n    struct Claim {\n        uint256 programsId;\n        address farmer;\n        uint256 amount;\n        ClaimStatus status;\n        bytes32 metadataHash; // hash/pointer to off-chain claim metadata\n        uint256 submittedAt;\n        string rejectionReason;\n    }\n\n    address public owner;\n    address public oracle; // trusted oracle/approver for automatic payouts\n    mapping(address => bool) public isGovernment; // multiple government addresses\n\n    uint256 public nextProgramId = 1;\n    uint256 public nextClaimId = 1;\n\n    mapping(uint256 => Program) public programs;\n    mapping(uint256 => Claim) public claims;\n    mapping(address => uint256[]) public enrolledPrograms; // farmer => list of programsIds\n    mapping(uint256 => mapping(address => bool)) public isFarmerEnrolled; // programsId => farmer enrolled\n    mapping(address => uint256) public agencyFunds; // agency address => balance (wei)\n\n    bool private reentrancyLock;\n\n    event OwnerUpdated(address indexed owner);\n    event OracleUpdated(address indexed oracle);\n    event GovernmentRoleGranted(address indexed account);\n    event GovernmentRoleRevoked(address indexed account);\n    event FundsDeposited(address indexed from, uint256 amount);\n    event ContractFunded(address indexed agency, uint256 amount);\n    event ProgramCreated(\n        uint256 indexed programsId,\n        string name,\n        ProgramType programsType,\n        ProgramStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        bytes32 metadataHash,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap\n    );\n    event ProgramStatusUpdated(\n        uint256 indexed programsId,\n        ProgramStatus status\n    );\n    event ProgramUpdated(\n        uint256 indexed programsId,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap\n    );\n    event EligibilityUpdated(uint256 indexed programsId);\n    event ClaimSubmitted(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        uint256 amount,\n        bytes32 metadataHash\n    );\n    event FarmerEnrolled(address indexed farmer, uint256 indexed programsId);\n    event AutoClaimCreated(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer\n    );\n    event ClaimApproved(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        uint256 amount\n    );\n    event ClaimPaid(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        uint256 amount\n    );\n    event ClaimRejected(\n        uint256 indexed claimId,\n        uint256 indexed programsId,\n        address indexed farmer,\n        string reason\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyGovernment() {\n        require(\n            msg.sender == owner || isGovernment[msg.sender],\n            \"Not government\"\n        );\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle || msg.sender == owner, \"Not oracle\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(!reentrancyLock, \"Reentrancy blocked\");\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n    constructor(address initialOracle) {\n        owner = msg.sender;\n        isGovernment[msg.sender] = true;\n        oracle = initialOracle;\n        emit OwnerUpdated(msg.sender);\n        emit GovernmentRoleGranted(msg.sender);\n        emit OracleUpdated(initialOracle);\n    }\n\n    // ---- Admin/oracle management ----\n\n    function updateOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Zero owner\");\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @notice Grant government role to an address.\n    function grantGovernmentRole(address account) external onlyOwner {\n        require(account != address(0), \"Zero account\");\n        require(!isGovernment[account], \"Already government\");\n        isGovernment[account] = true;\n        emit GovernmentRoleGranted(account);\n    }\n\n    /// @notice Revoke government role from an address (owner remains implicit government).\n    function revokeGovernmentRole(address account) external onlyOwner {\n        require(account != address(0), \"Zero account\");\n        require(account != owner, \"Cannot revoke owner\");\n        require(isGovernment[account], \"Not government\");\n        isGovernment[account] = false;\n        emit GovernmentRoleRevoked(account);\n    }\n\n    function updateOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"Zero oracle\");\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    // ---- Funding ----\n\n    /// @notice Deposit funds to agency's internal balance\n    function deposit() external payable {\n        require(msg.value > 0, \"No ETH\");\n        agencyFunds[msg.sender] += msg.value;\n        emit ContractFunded(msg.sender, msg.value);\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    receive() external payable {\n        agencyFunds[msg.sender] += msg.value;\n        emit ContractFunded(msg.sender, msg.value);\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    /// @notice Get agency's internal balance\n    function getAgencyBalance(address agency) external view returns (uint256) {\n        return agencyFunds[agency];\n    }\n\n    // ---- Program lifecycle ----\n\n    function createProgram(\n        string calldata name,\n        string calldata description,\n        ProgramType programsType,\n        ProgramStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        string calldata createdBy,\n        bytes32 metadataHash,\n        PayoutRule calldata payoutRule,\n        Eligibility calldata eligibility\n    ) external returns (uint256 programsId) {\n        require(bytes(name).length > 0, \"Name required\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        require(startDate < endDate, \"Invalid dates\");\n\n        programsId = nextProgramId++;\n\n        // store eligibility arrays in memory to storage\n        Eligibility storage e = programs[programsId].eligibility;\n        _setEligibility(e, eligibility);\n\n        programs[programsId].name = name;\n        programs[programsId].description = description;\n        programs[programsId].programsType = programsType;\n        programs[programsId].status = status;\n        programs[programsId].startDate = startDate;\n        programs[programsId].endDate = endDate;\n        programs[programsId].createdBy = createdBy;\n        programs[programsId].metadataHash = metadataHash;\n        programs[programsId].payoutRule = payoutRule;\n        programs[programsId].totalDisbursed = 0;\n\n        emit ProgramCreated(\n            programsId,\n            name,\n            programsType,\n            status,\n            startDate,\n            endDate,\n            metadataHash,\n            payoutRule.amount,\n            payoutRule.maxCap\n        );\n    }\n\n    function updateProgramStatus(\n        uint256 programsId,\n        ProgramStatus status\n    ) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        p.status = status;\n        emit ProgramStatusUpdated(programsId, status);\n    }\n\n    function updatePayoutRule(\n        uint256 programsId,\n        PayoutRule calldata payoutRule\n    ) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        p.payoutRule = payoutRule;\n        emit ProgramUpdated(programsId, payoutRule.amount, payoutRule.maxCap);\n    }\n\n    function updateEligibility(\n        uint256 programsId,\n        Eligibility calldata eligibility\n    ) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        _clearEligibilityArrays(p.eligibility);\n        _setEligibility(p.eligibility, eligibility);\n        emit EligibilityUpdated(programsId);\n    }\n\n    // ---- Claims ----\n\n    /// @notice Farmer opts into a programs before any automated claim generation.\n    function enrollInProgram(uint256 programsId) external {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(p.status == ProgramStatus.ACTIVE, \"Program not active\");\n        require(block.timestamp <= p.endDate, \"Program ended\");\n        require(!isFarmerEnrolled[programsId][msg.sender], \"Already enrolled\");\n\n        isFarmerEnrolled[programsId][msg.sender] = true;\n        enrolledPrograms[msg.sender].push(programsId);\n        emit FarmerEnrolled(msg.sender, programsId);\n    }\n\n    /// @notice Farmers submit a claim for a programs; amount is derived from programs payout rule.\n    function submitClaim(\n        uint256 programsId,\n        bytes32 metadataHash\n    ) external returns (uint256 claimId) {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        require(\n            block.timestamp >= p.startDate && block.timestamp <= p.endDate,\n            \"Outside window\"\n        );\n        require(\n            isFarmerEnrolled[programsId][msg.sender],\n            \"Farmer not enrolled\"\n        );\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            programsId: programsId,\n            farmer: msg.sender,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.PendingReview,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(\n            claimId,\n            programsId,\n            msg.sender,\n            p.payoutRule.amount,\n            metadataHash\n        );\n    }\n\n    /// @notice Oracle automation creates claims for all enrolled farmers when the hazard trigger occurs.\n    function autoCreateClaim(\n        uint256 programsId,\n        address farmer,\n        bytes32 metadataHash\n    ) external onlyOracle returns (uint256 claimId) {\n        Program storage p = programs[programsId];\n        require(bytes(p.name).length != 0, \"Program missing\");\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        require(\n            block.timestamp >= p.startDate && block.timestamp <= p.endDate,\n            \"Outside window\"\n        );\n        require(isFarmerEnrolled[programsId][farmer], \"Farmer not enrolled\");\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            programsId: programsId,\n            farmer: farmer,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.PendingReview,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(\n            claimId,\n            programsId,\n            farmer,\n            p.payoutRule.amount,\n            metadataHash\n        );\n        emit AutoClaimCreated(claimId, programsId, farmer);\n    }\n\n    /// @notice Oracle approves and pays out a claim in a single step (kept for compatibility).\n    function approveAndPayout(\n        uint256 claimId\n    ) external onlyOracle nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.Approved, \"Not approved\");\n        Program storage p = programs[c.programsId];\n        // Oracle uses contract balance, not agency funds\n        require(\n            address(this).balance >= c.amount,\n            \"Insufficient contract balance\"\n        );\n        _payoutApprovedClaim(claimId, c, p, address(0));\n    }\n\n    function rejectClaim(uint256 claimId, string calldata reason) external {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\n        c.status = ClaimStatus.Rejected;\n        c.rejectionReason = reason;\n        emit ClaimRejected(claimId, c.programsId, c.farmer, reason);\n    }\n\n    function approveClaim(uint256 claimId) external nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\n        Program storage p = programs[c.programsId];\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        require(agencyFunds[msg.sender] >= c.amount, \"Agency insufficient balance\");\n        c.status = ClaimStatus.Approved;\n        emit ClaimApproved(claimId, c.programsId, c.farmer, c.amount);\n        _payoutApprovedClaim(claimId, c, p, msg.sender);\n    }\n\n    // ---- Views ----\n\n    function getProgram(\n        uint256 programsId\n    ) external view returns (Program memory) {\n        return programs[programsId];\n    }\n\n    function getClaim(uint256 claimId) external view returns (Claim memory) {\n        return claims[claimId];\n    }\n\n    // ---- internal helpers ----\n\n    function _payoutApprovedClaim(\n        uint256 claimId,\n        Claim storage c,\n        Program storage p,\n        address agency\n    ) private {\n        require(p.status == ProgramStatus.ACTIVE, \"Program inactive\");\n        if (p.payoutRule.maxCap > 0) {\n            require(\n                p.totalDisbursed + c.amount <= p.payoutRule.maxCap,\n                \"Program cap exceeded\"\n            );\n        }\n        \n        // If agency is provided, use agency funds; otherwise use contract balance (for oracle)\n        if (agency != address(0)) {\n            require(agencyFunds[agency] >= c.amount, \"Agency insufficient balance\");\n            agencyFunds[agency] -= c.amount;\n        } else {\n            require(\n                address(this).balance >= c.amount,\n                \"Insufficient contract balance\"\n            );\n        }\n\n        p.totalDisbursed += c.amount;\n        c.status = ClaimStatus.Paid;\n\n        (bool ok, ) = c.farmer.call{value: c.amount}(\"\");\n        require(ok, \"Transfer failed\");\n\n        emit ClaimPaid(claimId, c.programsId, c.farmer, c.amount);\n    }\n\n    function _setEligibility(\n        Eligibility storage dest,\n        Eligibility calldata src\n    ) private {\n        dest.hasMinFarmSize = src.hasMinFarmSize;\n        dest.hasMaxFarmSize = src.hasMaxFarmSize;\n        dest.minFarmSize = src.minFarmSize;\n        dest.maxFarmSize = src.maxFarmSize;\n\n        for (uint256 i = 0; i < src.states.length; i++) {\n            dest.states.push(src.states[i]);\n        }\n        for (uint256 i = 0; i < src.districts.length; i++) {\n            dest.districts.push(src.districts[i]);\n        }\n        for (uint256 i = 0; i < src.cropTypes.length; i++) {\n            dest.cropTypes.push(src.cropTypes[i]);\n        }\n        for (uint256 i = 0; i < src.certifications.length; i++) {\n            dest.certifications.push(src.certifications[i]);\n        }\n    }\n\n    function _clearEligibilityArrays(Eligibility storage e) private {\n        delete e.states;\n        delete e.districts;\n        delete e.cropTypes;\n        delete e.certifications;\n    }\n}\n"
      }
    }
  }
}