{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-0c65d2e8fc0b80e22f8828409b40e47cc4b3dd80",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/Traceability.sol": "project/contracts/Traceability.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Traceability.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title Traceability - Agricultural Produce Traceability Contract\n/// @notice Records produce batches with immutable on-chain proofs for traceability.\n/// @dev This contract focuses on clarity and simplicity without inheritance.\ncontract Traceability {\n    /// @notice Represents a single produce batch record.\n    /// @dev Strings are used for batchId and hashes to align with off-chain systems.\n    struct Produce {\n        string batchId;      // Unique identifier for the batch (e.g., UUID or custom code)\n        string produceHash;  // Hash of the produce metadata/content (e.g., keccak256/sha256) stored as hex string\n        string qrHash;       // Hash encoded in QR or related reference, stored as hex/string\n        address recordedBy;      // Address that recorded the produce\n        uint256 timestamp;   // Block timestamp when the record was created\n    }\n\n    /// @notice Mapping from batchId to the recorded produce.\n    mapping(string => Produce) private produces;\n\n    /// @notice Emitted when a new produce batch is recorded on-chain.\n    /// @param batchId The unique batch identifier\n    /// @param recordedBy The address that recorded the batch\n    /// @param produceHash The hash representing the produce data\n    /// @param qrHash The QR-associated hash\n    /// @param timestamp The block timestamp when the record was stored\n    event ProduceRecorded(\n        string batchId,\n        address indexed recordedBy,\n        string produceHash,\n        string qrHash,\n        uint256 timestamp\n    );\n\n    /// @notice Records a new produce batch. Reverts if the batchId already exists.\n    /// @param batchId The unique batch identifier\n    /// @param produceHash The hash representing the produce data (hex or string)\n    /// @param qrHash The QR-associated hash (hex or string)\n    function recordProduce(\n        string memory batchId,\n        string memory produceHash,\n        string memory qrHash\n    ) external {\n        // Ensure the batch does not already exist by checking stored batchId length\n        require(bytes(produces[batchId].batchId).length == 0, \"Batch already recorded\");\n\n        // Create the record\n        Produce memory p = Produce({\n            batchId: batchId,\n            produceHash: produceHash,\n            qrHash: qrHash,\n            recordedBy: msg.sender,\n            timestamp: block.timestamp\n        });\n\n        // Persist to storage\n        produces[batchId] = p;\n\n        // Emit event for off-chain indexing/monitoring\n        emit ProduceRecorded(batchId, msg.sender, produceHash, qrHash, block.timestamp);\n    }\n\n    /// @notice Returns the full Produce record for the given batchId.\n    /// @dev Reverts if the batch is not found.\n    /// @param batchId The unique batch identifier\n    /// @return The Produce struct associated with the batchId\n    function getProduce(string memory batchId) public view returns (Produce memory) {\n        require(bytes(produces[batchId].batchId).length != 0, \"Batch not found\");\n        return produces[batchId];\n    }\n\n    /// @notice Verifies whether the provided hash matches the on-chain produceHash for the batch.\n    /// @param batchId The unique batch identifier\n    /// @param hashToCheck The hash to compare against the stored produceHash\n    /// @return True if the hashes match, false otherwise\n    function verifyProduce(\n        string memory batchId,\n        string memory hashToCheck\n    ) public view returns (bool) {\n        require(bytes(produces[batchId].batchId).length != 0, \"Batch not found\");\n        return keccak256(bytes(produces[batchId].produceHash)) == keccak256(bytes(hashToCheck));\n    }\n}\n\n"
      }
    }
  }
}