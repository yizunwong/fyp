{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-253f37c490e95eef442d396ccfc931e75aa8e689",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/SubsidyPayout.sol": "project/contracts/SubsidyPayout.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/SubsidyPayout.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SubsidyPayout - Automated subsidy disbursement aligned with policy schema\n/// @notice Mirrors the backend policy schema (policy, eligibility, triggers, payout rule) and executes payouts once an oracle approves claims.\ncontract SubsidyPayout {\n    enum PolicyType {\n        DROUGHT,\n        FLOOD,\n        CROP_LOSS,\n        MANUAL\n    }\n\n    enum PolicyStatus {\n        DRAFT,\n        ACTIVE,\n        ARCHIVED\n    }\n\n    enum TriggerOperator {\n        GT,\n        LT,\n        GTE,\n        LTE\n    }\n\n    enum WindowUnit {\n        HOURS,\n        DAYS\n    }\n\n    enum PayoutFrequency {\n        PER_TRIGGER,\n        ANNUAL,\n        MONTHLY\n    }\n\n    enum BeneficiaryCategory {\n        ALL_FARMERS,\n        SMALL_MEDIUM_FARMERS,\n        ORGANIC_FARMERS,\n        CERTIFIED_FARMERS\n    }\n\n    enum ClaimStatus {\n        Pending,\n        Approved,\n        Rejected,\n        Paid\n    }\n\n    struct Eligibility {\n        bool hasMinFarmSize;\n        bool hasMaxFarmSize;\n        uint256 minFarmSize;\n        uint256 maxFarmSize;\n        string[] states;\n        string[] districts;\n        string[] cropTypes;\n        string[] certifications;\n    }\n\n    struct Trigger {\n        string parameter;\n        TriggerOperator operator;\n        uint256 threshold;\n        uint256 windowValue;\n        WindowUnit windowUnit;\n    }\n\n    struct PayoutRule {\n        uint256 amount; // fixed payout per claim (wei)\n        uint256 maxCap; // total cap for the policy (0 = uncapped)\n        PayoutFrequency frequency;\n        BeneficiaryCategory beneficiaryCategory;\n    }\n\n    struct Policy {\n        string name;\n        string description;\n        PolicyType policyType;\n        PolicyStatus status;\n        uint256 startDate;\n        uint256 endDate;\n        string createdBy; // mirrors prisma createdBy string\n        PayoutRule payoutRule;\n        Eligibility eligibility;\n        uint256 totalDisbursed;\n    }\n\n    struct Claim {\n        uint256 policyId;\n        address farmer;\n        uint256 amount;\n        ClaimStatus status;\n        string metadataHash; // off-chain evidence or claim bundle hash\n        uint256 submittedAt;\n        string rejectionReason;\n    }\n\n    address public owner;\n    address public oracle; // trusted oracle/approver for automatic payouts\n\n    uint256 public nextPolicyId = 1;\n    uint256 public nextClaimId = 1;\n\n    mapping(uint256 => Policy) public policies;\n    mapping(uint256 => Claim) public claims;\n    mapping(uint256 => Trigger[]) private policyTriggers;\n\n    bool private reentrancyLock;\n\n    event OwnerUpdated(address indexed owner);\n    event OracleUpdated(address indexed oracle);\n    event FundsDeposited(address indexed from, uint256 amount);\n    event PolicyCreated(\n        uint256 indexed policyId,\n        string name,\n        PolicyType policyType,\n        PolicyStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap,\n        PayoutFrequency frequency,\n        BeneficiaryCategory beneficiaryCategory\n    );\n    event PolicyStatusUpdated(uint256 indexed policyId, PolicyStatus status);\n    event PolicyUpdated(\n        uint256 indexed policyId,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap,\n        PayoutFrequency frequency,\n        BeneficiaryCategory beneficiaryCategory\n    );\n    event EligibilityUpdated(uint256 indexed policyId);\n    event TriggerAdded(\n        uint256 indexed policyId,\n        string parameter,\n        TriggerOperator operatorValue,\n        uint256 threshold,\n        uint256 windowValue,\n        WindowUnit windowUnit\n    );\n    event TriggersCleared(uint256 indexed policyId);\n    event ClaimSubmitted(\n        uint256 indexed claimId,\n        uint256 indexed policyId,\n        address indexed farmer,\n        uint256 amount,\n        string metadataHash\n    );\n    event ClaimApproved(uint256 indexed claimId, uint256 indexed policyId, address indexed farmer, uint256 amount);\n    event ClaimRejected(uint256 indexed claimId, uint256 indexed policyId, address indexed farmer, string reason);\n    event TriggerRecorded(uint256 indexed policyId, string eventId, uint256 observedValue);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle || msg.sender == owner, \"Not oracle\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(!reentrancyLock, \"Reentrancy blocked\");\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n    constructor(address initialOracle) {\n        owner = msg.sender;\n        oracle = initialOracle;\n        emit OwnerUpdated(msg.sender);\n        emit OracleUpdated(initialOracle);\n    }\n\n    // ---- Admin/oracle management ----\n\n    function updateOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Zero owner\");\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    function updateOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"Zero oracle\");\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    // ---- Funding ----\n\n    function deposit() external payable {\n        require(msg.value > 0, \"No value\");\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    receive() external payable {\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    // ---- Policy lifecycle ----\n\n    function createPolicy(\n        string calldata name,\n        string calldata description,\n        PolicyType policyType,\n        PolicyStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        string calldata createdBy,\n        PayoutRule calldata payoutRule,\n        Eligibility calldata eligibility\n    ) external onlyOwner returns (uint256 policyId) {\n        require(bytes(name).length > 0, \"Name required\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        require(startDate < endDate, \"Invalid dates\");\n\n        policyId = nextPolicyId++;\n\n        // store eligibility arrays in memory to storage\n        Eligibility storage e = policies[policyId].eligibility;\n        _setEligibility(e, eligibility);\n\n        policies[policyId].name = name;\n        policies[policyId].description = description;\n        policies[policyId].policyType = policyType;\n        policies[policyId].status = status;\n        policies[policyId].startDate = startDate;\n        policies[policyId].endDate = endDate;\n        policies[policyId].createdBy = createdBy;\n        policies[policyId].payoutRule = payoutRule;\n        policies[policyId].totalDisbursed = 0;\n\n        emit PolicyCreated(\n            policyId,\n            name,\n            policyType,\n            status,\n            startDate,\n            endDate,\n            payoutRule.amount,\n            payoutRule.maxCap,\n            payoutRule.frequency,\n            payoutRule.beneficiaryCategory\n        );\n    }\n\n    function updatePolicyStatus(uint256 policyId, PolicyStatus status) external onlyOwner {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        p.status = status;\n        emit PolicyStatusUpdated(policyId, status);\n    }\n\n    function updatePayoutRule(uint256 policyId, PayoutRule calldata payoutRule) external onlyOwner {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        p.payoutRule = payoutRule;\n        emit PolicyUpdated(\n            policyId,\n            payoutRule.amount,\n            payoutRule.maxCap,\n            payoutRule.frequency,\n            payoutRule.beneficiaryCategory\n        );\n    }\n\n    function updateEligibility(uint256 policyId, Eligibility calldata eligibility) external onlyOwner {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        _clearEligibilityArrays(p.eligibility);\n        _setEligibility(p.eligibility, eligibility);\n        emit EligibilityUpdated(policyId);\n    }\n\n    function addTrigger(uint256 policyId, Trigger calldata trigger_) external onlyOwner {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        policyTriggers[policyId].push(trigger_);\n        emit TriggerAdded(\n            policyId,\n            trigger_.parameter,\n            trigger_.operator,\n            trigger_.threshold,\n            trigger_.windowValue,\n            trigger_.windowUnit\n        );\n    }\n\n    function clearTriggers(uint256 policyId) external onlyOwner {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        delete policyTriggers[policyId];\n        emit TriggersCleared(policyId);\n    }\n\n    // ---- Claims ----\n\n    /// @notice Farmers submit a claim for a policy; amount is derived from policy payout rule.\n    function submitClaim(uint256 policyId, string calldata metadataHash) external returns (uint256 claimId) {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        require(p.status == PolicyStatus.ACTIVE, \"Policy inactive\");\n        require(block.timestamp >= p.startDate && block.timestamp <= p.endDate, \"Outside window\");\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            policyId: policyId,\n            farmer: msg.sender,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.Pending,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(claimId, policyId, msg.sender, p.payoutRule.amount, metadataHash);\n    }\n\n    /// @notice Oracle approves and pays out a claim in a single step.\n    function approveAndPayout(uint256 claimId) external onlyOracle nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.Pending, \"Not pending\");\n\n        Policy storage p = policies[c.policyId];\n        require(p.status == PolicyStatus.ACTIVE, \"Policy inactive\");\n\n        if (p.payoutRule.maxCap > 0) {\n            require(p.totalDisbursed + c.amount <= p.payoutRule.maxCap, \"Policy cap exceeded\");\n        }\n        require(address(this).balance >= c.amount, \"Insufficient contract balance\");\n\n        c.status = ClaimStatus.Approved;\n        p.totalDisbursed += c.amount;\n        c.status = ClaimStatus.Paid;\n\n        (bool ok, ) = c.farmer.call{value: c.amount}(\"\");\n        require(ok, \"Transfer failed\");\n\n        emit ClaimApproved(claimId, c.policyId, c.farmer, c.amount);\n    }\n\n    function rejectClaim(uint256 claimId, string calldata reason) external onlyOracle {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.Pending, \"Not pending\");\n        c.status = ClaimStatus.Rejected;\n        c.rejectionReason = reason;\n        emit ClaimRejected(claimId, c.policyId, c.farmer, reason);\n    }\n\n    // ---- Trigger logging ----\n\n    /// @notice Record an oracle-observed trigger for auditability; off-chain systems can match this to claims.\n    function recordTriggerHit(uint256 policyId, string calldata eventId, uint256 observedValue) external onlyOracle {\n        require(bytes(policies[policyId].name).length != 0, \"Policy missing\");\n        emit TriggerRecorded(policyId, eventId, observedValue);\n    }\n\n    // ---- Views ----\n\n    function getPolicy(uint256 policyId) external view returns (Policy memory) {\n        return policies[policyId];\n    }\n\n    function getTriggers(uint256 policyId) external view returns (Trigger[] memory) {\n        return policyTriggers[policyId];\n    }\n\n    function getClaim(uint256 claimId) external view returns (Claim memory) {\n        return claims[claimId];\n    }\n\n    // ---- internal helpers ----\n\n    function _setEligibility(Eligibility storage dest, Eligibility calldata src) private {\n        dest.hasMinFarmSize = src.hasMinFarmSize;\n        dest.hasMaxFarmSize = src.hasMaxFarmSize;\n        dest.minFarmSize = src.minFarmSize;\n        dest.maxFarmSize = src.maxFarmSize;\n\n        for (uint256 i = 0; i < src.states.length; i++) {\n            dest.states.push(src.states[i]);\n        }\n        for (uint256 i = 0; i < src.districts.length; i++) {\n            dest.districts.push(src.districts[i]);\n        }\n        for (uint256 i = 0; i < src.cropTypes.length; i++) {\n            dest.cropTypes.push(src.cropTypes[i]);\n        }\n        for (uint256 i = 0; i < src.certifications.length; i++) {\n            dest.certifications.push(src.certifications[i]);\n        }\n    }\n\n    function _clearEligibilityArrays(Eligibility storage e) private {\n        delete e.states;\n        delete e.districts;\n        delete e.cropTypes;\n        delete e.certifications;\n    }\n}\n"
      }
    }
  }
}