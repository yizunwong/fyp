{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-ef63bccd2c5bf9041b28c3d38bbdb5bdaefc1ab5",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/SubsidyPayout.sol": "project/contracts/SubsidyPayout.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [],
      "viaIR": true
    },
    "sources": {
      "project/contracts/SubsidyPayout.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title SubsidyPayout - Automated subsidy disbursement aligned with policy schema\n/// @notice Mirrors the backend policy schema (policy, eligibility, payout rule) and executes payouts once an oracle approves claims.\ncontract SubsidyPayout {\n    enum PolicyType {\n        DROUGHT,\n        FLOOD,\n        CROP_LOSS,\n        MANUAL\n    }\n\n    enum PolicyStatus {\n        DRAFT,\n        ACTIVE,\n        ARCHIVED\n    }\n\n    enum ClaimStatus {\n        PendingReview,\n        Approved,\n        Rejected,\n        Paid\n    }\n\n    struct Eligibility {\n        bool hasMinFarmSize;\n        bool hasMaxFarmSize;\n        uint256 minFarmSize;\n        uint256 maxFarmSize;\n        string[] states;\n        string[] districts;\n        string[] cropTypes;\n        string[] certifications;\n    }\n\n    struct PayoutRule {\n        uint256 amount; // fixed payout per claim (wei)\n        uint256 maxCap; // total cap for the policy (0 = uncapped)\n    }\n\n    struct Policy {\n        string name;\n        string description;\n        PolicyType policyType;\n        PolicyStatus status;\n        uint256 startDate;\n        uint256 endDate;\n        string createdBy; // mirrors prisma createdBy string\n        bytes32 metadataHash; // hash/pointer to full off-chain policy config\n        PayoutRule payoutRule;\n        Eligibility eligibility;\n        uint256 totalDisbursed;\n    }\n\n    struct Claim {\n        uint256 policyId;\n        address farmer;\n        uint256 amount;\n        ClaimStatus status;\n        bytes32 metadataHash; // hash/pointer to off-chain claim metadata\n        uint256 submittedAt;\n        string rejectionReason;\n    }\n\n    address public owner;\n    address public oracle; // trusted oracle/approver for automatic payouts\n    mapping(address => bool) public isGovernment; // multiple government addresses\n\n    uint256 public nextPolicyId = 1;\n    uint256 public nextClaimId = 1;\n\n    mapping(uint256 => Policy) public policies;\n    mapping(uint256 => Claim) public claims;\n    mapping(address => uint256[]) public enrolledPolicies; // farmer => list of policyIds\n    mapping(uint256 => mapping(address => bool)) public isFarmerEnrolled; // policyId => farmer enrolled\n\n    bool private reentrancyLock;\n\n    event OwnerUpdated(address indexed owner);\n    event OracleUpdated(address indexed oracle);\n    event GovernmentRoleGranted(address indexed account);\n    event GovernmentRoleRevoked(address indexed account);\n    event FundsDeposited(address indexed from, uint256 amount);\n    event PolicyCreated(\n        uint256 indexed policyId,\n        string name,\n        PolicyType policyType,\n        PolicyStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        bytes32 metadataHash,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap\n    );\n    event PolicyStatusUpdated(uint256 indexed policyId, PolicyStatus status);\n    event PolicyUpdated(\n        uint256 indexed policyId,\n        uint256 payoutAmount,\n        uint256 payoutMaxCap\n    );\n    event EligibilityUpdated(uint256 indexed policyId);\n    event ClaimSubmitted(\n        uint256 indexed claimId,\n        uint256 indexed policyId,\n        address indexed farmer,\n        uint256 amount,\n        bytes32 metadataHash\n    );\n    event FarmerEnrolled(address indexed farmer, uint256 indexed policyId);\n    event AutoClaimCreated(uint256 indexed claimId, uint256 indexed policyId, address indexed farmer);\n    event ClaimApproved(uint256 indexed claimId, uint256 indexed policyId, address indexed farmer, uint256 amount);\n    event ClaimPaid(uint256 indexed claimId, uint256 indexed policyId, address indexed farmer, uint256 amount);\n    event ClaimRejected(uint256 indexed claimId, uint256 indexed policyId, address indexed farmer, string reason);\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier onlyGovernment() {\n        require(msg.sender == owner || isGovernment[msg.sender], \"Not government\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracle || msg.sender == owner, \"Not oracle\");\n        _;\n    }\n\n    modifier nonReentrant() {\n        require(!reentrancyLock, \"Reentrancy blocked\");\n        reentrancyLock = true;\n        _;\n        reentrancyLock = false;\n    }\n\n    constructor(address initialOracle) {\n        owner = msg.sender;\n        isGovernment[msg.sender] = true;\n        oracle = initialOracle;\n        emit OwnerUpdated(msg.sender);\n        emit GovernmentRoleGranted(msg.sender);\n        emit OracleUpdated(initialOracle);\n    }\n\n    // ---- Admin/oracle management ----\n\n    function updateOwner(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Zero owner\");\n        owner = newOwner;\n        emit OwnerUpdated(newOwner);\n    }\n\n    /// @notice Grant government role to an address.\n    function grantGovernmentRole(address account) external onlyOwner {\n        require(account != address(0), \"Zero account\");\n        require(!isGovernment[account], \"Already government\");\n        isGovernment[account] = true;\n        emit GovernmentRoleGranted(account);\n    }\n\n    /// @notice Revoke government role from an address (owner remains implicit government).\n    function revokeGovernmentRole(address account) external onlyOwner {\n        require(account != address(0), \"Zero account\");\n        require(account != owner, \"Cannot revoke owner\");\n        require(isGovernment[account], \"Not government\");\n        isGovernment[account] = false;\n        emit GovernmentRoleRevoked(account);\n    }\n\n    function updateOracle(address newOracle) external onlyOwner {\n        require(newOracle != address(0), \"Zero oracle\");\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    // ---- Funding ----\n\n    function deposit() external payable {\n        require(msg.value > 0, \"No value\");\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    receive() external payable {\n        emit FundsDeposited(msg.sender, msg.value);\n    }\n\n    // ---- Policy lifecycle ----\n\n    function createPolicy(\n        string calldata name,\n        string calldata description,\n        PolicyType policyType,\n        PolicyStatus status,\n        uint256 startDate,\n        uint256 endDate,\n        string calldata createdBy,\n        bytes32 metadataHash,\n        PayoutRule calldata payoutRule,\n        Eligibility calldata eligibility\n    ) external onlyGovernment returns (uint256 policyId) {\n        require(bytes(name).length > 0, \"Name required\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        require(startDate < endDate, \"Invalid dates\");\n\n        policyId = nextPolicyId++;\n\n        // store eligibility arrays in memory to storage\n        Eligibility storage e = policies[policyId].eligibility;\n        _setEligibility(e, eligibility);\n\n        policies[policyId].name = name;\n        policies[policyId].description = description;\n        policies[policyId].policyType = policyType;\n        policies[policyId].status = status;\n        policies[policyId].startDate = startDate;\n        policies[policyId].endDate = endDate;\n        policies[policyId].createdBy = createdBy;\n        policies[policyId].metadataHash = metadataHash;\n        policies[policyId].payoutRule = payoutRule;\n        policies[policyId].totalDisbursed = 0;\n\n        emit PolicyCreated(\n            policyId,\n            name,\n            policyType,\n            status,\n            startDate,\n            endDate,\n            metadataHash,\n            payoutRule.amount,\n            payoutRule.maxCap\n        );\n    }\n\n    function updatePolicyStatus(uint256 policyId, PolicyStatus status) external onlyGovernment {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        p.status = status;\n        emit PolicyStatusUpdated(policyId, status);\n    }\n\n    function updatePayoutRule(uint256 policyId, PayoutRule calldata payoutRule) external onlyGovernment {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        require(payoutRule.amount > 0, \"Payout must be > 0\");\n        p.payoutRule = payoutRule;\n        emit PolicyUpdated(policyId, payoutRule.amount, payoutRule.maxCap);\n    }\n\n    function updateEligibility(uint256 policyId, Eligibility calldata eligibility) external onlyGovernment {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        _clearEligibilityArrays(p.eligibility);\n        _setEligibility(p.eligibility, eligibility);\n        emit EligibilityUpdated(policyId);\n    }\n\n    // ---- Claims ----\n\n    /// @notice Farmer opts into a policy before any automated claim generation.\n    function enrollInPolicy(uint256 policyId) external {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        require(p.status == PolicyStatus.ACTIVE, \"Policy not active\");\n        require(block.timestamp <= p.endDate, \"Policy ended\");\n        require(!isFarmerEnrolled[policyId][msg.sender], \"Already enrolled\");\n\n        isFarmerEnrolled[policyId][msg.sender] = true;\n        enrolledPolicies[msg.sender].push(policyId);\n        emit FarmerEnrolled(msg.sender, policyId);\n    }\n\n    /// @notice Farmers submit a claim for a policy; amount is derived from policy payout rule.\n    function submitClaim(uint256 policyId, bytes32 metadataHash) external returns (uint256 claimId) {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        require(p.status == PolicyStatus.ACTIVE, \"Policy inactive\");\n        require(block.timestamp >= p.startDate && block.timestamp <= p.endDate, \"Outside window\");\n        require(isFarmerEnrolled[policyId][msg.sender], \"Farmer not enrolled\");\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            policyId: policyId,\n            farmer: msg.sender,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.PendingReview,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(claimId, policyId, msg.sender, p.payoutRule.amount, metadataHash);\n    }\n\n    /// @notice Oracle automation creates claims for all enrolled farmers when the hazard trigger occurs.\n    function autoCreateClaim(uint256 policyId, address farmer, bytes32 metadataHash) external onlyOracle returns (uint256 claimId) {\n        Policy storage p = policies[policyId];\n        require(bytes(p.name).length != 0, \"Policy missing\");\n        require(p.status == PolicyStatus.ACTIVE, \"Policy inactive\");\n        require(block.timestamp >= p.startDate && block.timestamp <= p.endDate, \"Outside window\");\n        require(isFarmerEnrolled[policyId][farmer], \"Farmer not enrolled\");\n\n        claimId = nextClaimId++;\n        claims[claimId] = Claim({\n            policyId: policyId,\n            farmer: farmer,\n            amount: p.payoutRule.amount,\n            status: ClaimStatus.PendingReview,\n            metadataHash: metadataHash,\n            submittedAt: block.timestamp,\n            rejectionReason: \"\"\n        });\n\n        emit ClaimSubmitted(claimId, policyId, farmer, p.payoutRule.amount, metadataHash);\n        emit AutoClaimCreated(claimId, policyId, farmer);\n    }\n\n    /// @notice Oracle approves and pays out a claim in a single step (kept for compatibility).\n    function approveAndPayout(uint256 claimId) external onlyOracle nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.Approved, \"Not approved\");\n        Policy storage p = policies[c.policyId];\n        _payoutApprovedClaim(claimId, c, p);\n    }\n\n    function rejectClaim(uint256 claimId, string calldata reason) external onlyGovernment {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\n        c.status = ClaimStatus.Rejected;\n        c.rejectionReason = reason;\n        emit ClaimRejected(claimId, c.policyId, c.farmer, reason);\n    }\n\n    function approveClaim(uint256 claimId) external onlyGovernment nonReentrant {\n        Claim storage c = claims[claimId];\n        require(c.status == ClaimStatus.PendingReview, \"Not pending\");\n        Policy storage p = policies[c.policyId];\n        require(p.status == PolicyStatus.ACTIVE, \"Policy inactive\");\n        c.status = ClaimStatus.Approved;\n        emit ClaimApproved(claimId, c.policyId, c.farmer, c.amount);\n        _payoutApprovedClaim(claimId, c, p);\n    }\n\n    // ---- Views ----\n\n    function getPolicy(uint256 policyId) external view returns (Policy memory) {\n        return policies[policyId];\n    }\n\n    function getClaim(uint256 claimId) external view returns (Claim memory) {\n        return claims[claimId];\n    }\n\n    // ---- internal helpers ----\n\n    function _payoutApprovedClaim(uint256 claimId, Claim storage c, Policy storage p) private {\n        require(p.status == PolicyStatus.ACTIVE, \"Policy inactive\");\n        if (p.payoutRule.maxCap > 0) {\n            require(p.totalDisbursed + c.amount <= p.payoutRule.maxCap, \"Policy cap exceeded\");\n        }\n        require(address(this).balance >= c.amount, \"Insufficient contract balance\");\n\n        p.totalDisbursed += c.amount;\n        c.status = ClaimStatus.Paid;\n\n        (bool ok, ) = c.farmer.call{value: c.amount}(\"\");\n        require(ok, \"Transfer failed\");\n\n        emit ClaimPaid(claimId, c.policyId, c.farmer, c.amount);\n    }\n\n    function _setEligibility(Eligibility storage dest, Eligibility calldata src) private {\n        dest.hasMinFarmSize = src.hasMinFarmSize;\n        dest.hasMaxFarmSize = src.hasMaxFarmSize;\n        dest.minFarmSize = src.minFarmSize;\n        dest.maxFarmSize = src.maxFarmSize;\n\n        for (uint256 i = 0; i < src.states.length; i++) {\n            dest.states.push(src.states[i]);\n        }\n        for (uint256 i = 0; i < src.districts.length; i++) {\n            dest.districts.push(src.districts[i]);\n        }\n        for (uint256 i = 0; i < src.cropTypes.length; i++) {\n            dest.cropTypes.push(src.cropTypes[i]);\n        }\n        for (uint256 i = 0; i < src.certifications.length; i++) {\n            dest.certifications.push(src.certifications[i]);\n        }\n    }\n\n    function _clearEligibilityArrays(Eligibility storage e) private {\n        delete e.states;\n        delete e.districts;\n        delete e.cropTypes;\n        delete e.certifications;\n    }\n}\n"
      }
    }
  }
}